<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>yu docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.介绍.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="2.快速开始.html"><strong aria-hidden="true">2.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="3.基本原理.html"><strong aria-hidden="true">3.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="4.0组件.html"><strong aria-hidden="true">4.</strong> 组件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1blockchain.html"><strong aria-hidden="true">4.1.</strong> blockchain</a></li><li class="chapter-item expanded "><a href="4.2blockbase.html"><strong aria-hidden="true">4.2.</strong> blockbase</a></li><li class="chapter-item expanded "><a href="4.3txpool.html"><strong aria-hidden="true">4.3.</strong> txpool</a></li><li class="chapter-item expanded "><a href="4.4tripod.html"><strong aria-hidden="true">4.4.</strong> tripod</a></li><li class="chapter-item expanded "><a href="4.5state.html"><strong aria-hidden="true">4.5.</strong> state</a></li></ol></li><li class="chapter-item expanded "><a href="5.0dev.html"><strong aria-hidden="true">5.</strong> 开发者手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1配置文件.html"><strong aria-hidden="true">5.1.</strong> 配置文件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1.1节点配置.html"><strong aria-hidden="true">5.1.1.</strong> 节点配置</a></li><li class="chapter-item expanded "><a href="5.1.2各组件配置.html"><strong aria-hidden="true">5.1.2.</strong> 各组件配置</a></li><li class="chapter-item expanded "><a href="5.1.3P2P网络配置.html"><strong aria-hidden="true">5.1.3.</strong> P2P网络配置</a></li><li class="chapter-item expanded "><a href="5.1.4nodekepper配置.html"><strong aria-hidden="true">5.1.4.</strong> NodeKeeper配置（暂不用）</a></li></ol></li><li class="chapter-item expanded "><a href="5.2context与chainEnv.html"><strong aria-hidden="true">5.2.</strong> Context 与 chainEnv</a></li><li class="chapter-item expanded "><a href="5.3execution_and_query.html"><strong aria-hidden="true">5.3.</strong> Excutrion 与 Query</a></li><li class="chapter-item expanded "><a href="5.4区块周期.html"><strong aria-hidden="true">5.4.</strong> 区块周期</a></li><li class="chapter-item expanded "><a href="5.5建立区块链网络.html"><strong aria-hidden="true">5.5.</strong> 建立区块链网络</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">yu docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>yu(禹) 是一个用golang开发的 简单易用 且 高度可定制化的区块链框架。 现有的绝大多数区块链（公链与联盟链）都可以用 yu 来开发出来。</p>
<h3 id="我为什么要开发-yu禹"><a class="header" href="#我为什么要开发-yu禹">我为什么要开发 yu(禹)</a></h3>
<p>现如今的区块链框架，要么上手门槛很高，要么可定制化的程度很低，要么社区不活跃停止维护了。所以我才自己开发了
这款区块链框架。 目的是为了让开发者们可以更简单快速、更深入的上手区块链开发的核心。</p>
<h3 id="yu禹可以定制哪些功能"><a class="header" href="#yu禹可以定制哪些功能">yu(禹)可以定制哪些功能</a></h3>
<ul>
<li>可使用多种编程语言开发（尚未完成）</li>
<li>定制共识算法，包括但不仅限于pow、pos、poa、pbft等等</li>
<li>自定义区块验证逻辑、交易验证逻辑、从交易池中打包交易的规则</li>
<li>在区块生成周期的各个阶段插入自定义的操作，包括控制何时执行交易</li>
<li>自定义链上交易(即Execution，在以太坊中称为交易) 和 查询(query)</li>
<li>自定义链结构（包括分叉逻辑）和 交易池逻辑</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<h4 id="安装"><a class="header" href="#安装">安装</a></h4>
<pre><code>go get github.com/Lawliet-Chan/yu
</code></pre>
<h4 id="开发一个链上的-execution-和-query"><a class="header" href="#开发一个链上的-execution-和-query">开发一个链上的 Execution 和 Query</a></h4>
<pre><code class="language-go">import (
	&quot;github.com/Lawliet-Chan/yu/apps/pow&quot;
	&quot;github.com/Lawliet-Chan/yu/chain_env&quot;
	&quot;github.com/Lawliet-Chan/yu/common&quot;
	&quot;github.com/Lawliet-Chan/yu/context&quot;
	&quot;github.com/Lawliet-Chan/yu/startup&quot;
	&quot;github.com/Lawliet-Chan/yu/tripod&quot;
)

type Example struct {
	*tripod.DefaultTripod
}

// 此处定制开发一个 Execution
func (e *Example) Exec(ctx *context.Context, env *chain_env.ChainEnv) error {
	caller := ctx.Caller
        // 将数据存入链上状态中。
	env.KVDB.Set(e, caller.Bytes(), []byte(&quot;yu&quot;))
        // 向链外发射一个event
	return ctx.EmitEvent(&quot;execute success&quot;)
}

// 此处定制开发一个 Query
func (e *Example) Qry(ctx *context.Context, env *chain_env.ChainEnv, _ common.Hash) (interface{}, error) {
	caller := ctx.Caller
	value, err := env.KVDB.Get(e, caller.Bytes())
	return string(value), err
}

</code></pre>
<h4 id="在main函数中添加-tripods"><a class="header" href="#在main函数中添加-tripods">在main函数中添加 tripods</a></h4>
<pre><code class="language-go">func NewExample() *Example {
	df := tripod.NewDefaultTripod(&quot;example&quot;)
	e := &amp;Example{df}

        // 此处需要手动将自定义的 Execution 注册到 tripod 中，
        // 这里的 10 表示设置该操作所需要消耗的 lei 的数量 （lei 和 gas同义）
	e.SetExec(e.Exec, 10)
        // 此处需要手动将自定义的 Query 注册到 tripod 中
	e.SetQueries(e.Qry)

	return e
}

func main() {
	startup.StartUp(pow.NewPow(1024), NewExample())
}
</code></pre>
<h4 id="运行"><a class="header" href="#运行">运行</a></h4>
<pre><code class="language-zsh">go build -o yu-example

// -dc=true 表示使用默认配置，无需另行配置文件。
./yu-example -dc=true
 
</code></pre>
<p>至此，一条区块链便启动起来了。 后续可以加入更多区块链节点来<a href="5.5%E5%BB%BA%E7%AB%8B%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C.html">构建区块链网络</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h1>
<h3 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h3>
<h3 id="流程总览"><a class="header" href="#流程总览">流程总览</a></h3>
<p><img src="yu%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image" /></p>
<p>从客户端发起一个交易到链上， 会先经过 <code>txpool</code> 的检查， 当检查通过后才会被放入交易池当中 并且 广播给其他区块链节点。<br />
从 P2P 网络里接收到来自其他节点广播的交易，检查通过后放入 <code>txpool</code> 中（不再广播） </p>
<p><code>land</code>运行，开始生成区块，并且对区块进行一系列的处理：包括挖矿出块、广播、验证来自其他节点的区块、执行区块内交易、将区块存入链 等等。 在这个过程中
可以自由控制的事情有非常多,你可以通过它实现你想要的任何共识算法、分片方式、出块时间、打包交易方式、选择何时执行交易 等等。 与<code>blockchain</code>， 
<code>blockbase</code>, <code>state</code>的交互也在这个过程中。</p>
<p>每个区块经过 <code>land</code> 内所有 自定义<code>tripod</code>的逻辑之后， 会进入下一个区块阶段，生成下一个区块并处理，周而复始下去。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件"><a class="header" href="#组件">组件</a></h1>
<h3 id="组件-1"><a class="header" href="#组件-1">组件</a></h3>
<h4 id="核心组件"><a class="header" href="#核心组件">核心组件</a></h4>
<p>以下的 <code>blockchain</code>，<code>blockbase</code>，<code>txpool</code> 均为interface， 内置默认的实现， 如果开发者有特殊需求，可自行重新实现interface</p>
<ul>
<li>blockchain: 链结构，负责存储区块数据 并 组织链结构与分叉逻辑。</li>
<li>blockbase: 区块库，存储所有区块中的具体交易数据、 交易执行后的 <code>event</code> 和 <code>error</code>。</li>
<li>txpool: 交易池，负责验证和缓存从外部发来的交易。</li>
<li>state: 存储状态， 储存着每个交易执行后的状态，比如账户余额等。</li>
<li>tripod: 运行区块链 和 供开发者定制逻辑 的 基本最小单元， 开发者可以定制多个tripod并将他们排序组合装载入<code>land</code>里供框架调用。</li>
</ul>
<h4 id="底层组件"><a class="header" href="#底层组件">底层组件</a></h4>
<ul>
<li>store: 存储层，支持 kv、sql、 fs 等多种形式的存储，且均为interface，开发者可以指定需要的存储引擎（比如kv目前具备<code>badger</code>和<code>boltdb</code>两种存储引擎）
目前<code>state</code>内的存储是用<code>boltdb</code>实现的， 而<code>blockchain</code>和<code>blockbase</code>内的存储使用<code>sqlite</code>实现的</li>
<li>p2p: 点对点传输网络，用来发现网络中的节点以及传播交易和区块等。 </li>
<li>keypair: 公私钥的非对称加密算法，目前支持 <code>sr25519</code>和<code>ed25519</code>。该组件以interface形式，可自行扩展其他加密算法。</li>
</ul>
<p><img src="yu%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链"><a class="header" href="#区块链">区块链</a></h1>
<p><code>blockchain</code>组件内部有两个部分构成，一部分缓存区，专门用来储存来自P2P网络中发送来的区块数据（存入缓存区之前已经经过验证）以备处理。另一个部分
就是真正的区块链持久化存储，全网统一维护的链结构。</p>
<h3 id="接口"><a class="header" href="#接口">接口</a></h3>
<p>代码在<a href="https://github.com/Lawliet-Chan/yu/blob/master/blockchain/interfaces.go#L51">这里</a><br />
<code>blockchain</code>实现了基本的链结构的存储和处理逻辑。以下为核心功能的接口，开发者如有需求，可自行定制属于自己的链存储方式和处理逻辑： </p>
<pre><code class="language-go">func ConvergeType() ConvergeType
</code></pre>
<p><code>ConvergeType()</code>返回链的收敛类型（即区块以何种形式被最终确定下来） 
众所周知，在区块链中，同一个时刻是可能有多个节点出块的，因此形成分叉。 如果不收敛，系统会不知道哪条链为主链的。所以需要收敛，而收敛方式目前最常见的有几种：<br />
最长子链(Longest)： 最长的那条分支会被认为是主链，该方式会被回滚。<br />
最重子链(Heaviest): 子链数量最多的分叉会被认为是主链， 该方式会被回滚。<br />
敲定(Finalize): 通过投票等方式对区块或者链进行投票 来最终敲定某个分叉成为主链，正常情况下被敲定的区块无法被回滚。</p>
<h2 id=""><a class="header" href="#"></a></h2>
<pre><code class="language-go">func GetGenesis() (IBlock, error)
func SetGenesis(b IBlock) error
</code></pre>
<p>从链内获取创世区块，把创世区块存入链。</p>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<pre><code class="language-go">func InsertBlockFromP2P(ib IBlock) error
func TakeP2pBlocksBefore(height BlockNum) (map[BlockNum][]IBlock, error)
func TakeP2pBlocks(height BlockNum) ([]IBlock, error)
</code></pre>
<p><code>InsertBlockFromP2P(block)</code>将从P2P网络收到的经过验证的区块纳入一个缓存区，以备后续处理。<br />
<code>TakeP2pBlocksBefore(height)</code>将从上述缓存区取走高度 &lt; <code>height</code>的所有区块。<br />
<code>TakeP2pBlocks(height)</code>将从上述缓存区取走高度 = <code>height</code>的所有区块。</p>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<pre><code class="language-go">func AppendBlock(b IBlock) error
func GetBlock(blockHash Hash) (IBlock, error)
func UpdateBlock(b IBlock) error
</code></pre>
<p><code>AppendBlock(block)</code>将区块加入到链的末尾<br />
<code>GetBlock(blockHash)</code>根据区块哈希获取具体的区块<br />
<code>UpdateBlock(block)</code>以区块哈希为索引更新区块数据</p>
<h2 id="-3"><a class="header" href="#-3"></a></h2>
<pre><code class="language-go">func Children(prevBlockHash Hash) ([]IBlock, error)  
func Finalize(blockHash Hash) error  
func Chain() (IChainStruct, error)
</code></pre>
<p><code>Children(blockHash)</code> 根据一个区块哈希获取它的所有子区块<br />
<code>Finalize(blockHash)</code> 最终共识敲定一个区块<br />
<code>Chain()</code> 获取主链</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块库"><a class="header" href="#区块库">区块库</a></h1>
<p><code>blockbase</code>存储所有区块中的具体交易数据、 交易执行后的 <code>event</code> 和 <code>error</code>。</p>
<h3 id="接口-1"><a class="header" href="#接口-1">接口</a></h3>
<p>代码在<a href="https://github.com/Lawliet-Chan/yu/blob/master/blockchain/interfaces.go#L93">这里</a><br />
以下为核心功能的接口，开发者如有需求，可自行定制属于自己的区块库。</p>
<pre><code class="language-go">func GetTxn(txnHash Hash) (*SignedTxn, error)
func SetTxn(stxn *SignedTxn) error
</code></pre>
<p><code>GetTxn(txnHash)</code>根据交易的哈希值获取交易数据<br />
<code>SetTxn(stxn)</code>把交易数据存入区块库（以交易哈希为索引）</p>
<h2 id="-4"><a class="header" href="#-4"></a></h2>
<pre><code class="language-go">func GetTxns(blockHash Hash) ([]*SignedTxn, error)
func SetTxns(blockHash Hash, txns []*SignedTxn) error
</code></pre>
<p><code>GetTxns(blockHash)</code>根据 区块哈希 获取该区块中的所有 交易数据<br />
<code>SetTxns(blockHash, txns)</code>把一个区块中的所有交易数据存入区块库中（以交易哈希为索引）</p>
<h2 id="-5"><a class="header" href="#-5"></a></h2>
<pre><code class="language-go">func GetEvents(blockHash Hash) ([]*Event, error)
func SetEvents(events []*Event) error
</code></pre>
<p><code>GetEvents(blockHash)</code>根据 区块哈希 获取该区块中所有的 <code>event</code><br />
<code>SetEvents(events）</code>把所有<code>event</code>存入区块库中（以自增ID为索引）</p>
<h2 id="-6"><a class="header" href="#-6"></a></h2>
<pre><code class="language-go">func GetErrors(blockHash Hash) ([]*Error, error)
func SetError(err *Error) error
</code></pre>
<p><code>GetErrors(blockHash)</code>根据 区块哈希 获取该区块中所有的 <code>error</code><br />
<code>SetError(err)</code> 把所有<code>error</code>存入区块库中（以自增ID为索引）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交易池"><a class="header" href="#交易池">交易池</a></h1>
<p>接口代码定义在<a href="https://github.com/Lawliet-Chan/yu/blob/master/txpool/txpool.go">这里</a><br />
以下为核心功能的接口，开发者如有需求，可自行定制属于自己的交易池</p>
<pre><code class="language-go">func BaseCheck(*SignedTxn) error
func TripodsCheck(stxn *SignedTxn) error
func NecessaryCheck(stxn *SignedTxn) error
</code></pre>
<p><code>BaseCheck()</code>插入交易数据到交易池的时候，会做一些基础检查，基础检查有: 交易数据是否过大，交易池容量是否已达上限，交易中的签名是否合法，是否有
交易重复。前三者如果检查不通过会返回错误， 交易重复的时候会忽略该条消息但是不会返回错误。<br />
<code>TripodsCheck()</code> 基础检查完毕之后，会进行tripods检查，此为开发者自行定义的交易检查规则。<br />
<code>NecessaryCheck()</code>表示必要性检查，只检查交易数据是否过大、签名是否合法以及 tripods检查。 在节点收到来自P2P网络的区块之后，同步
区块中的交易数据时做该检查，检查后直接存入<code>blockbase</code>。</p>
<h2 id="-7"><a class="header" href="#-7"></a></h2>
<pre><code class="language-go">func Insert(txn *SignedTxn) error
</code></pre>
<p><code>Insert()</code>表示插入交易数据到交易池， 该功能内部带有 <code>BaseCheck</code> 和 <code>TripodsCheck</code>两类检查， 只有通过检查才会被真正插入交易池，否则会返回错误。</p>
<h2 id="-8"><a class="header" href="#-8"></a></h2>
<pre><code class="language-go">func Pack(numLimit uint64) ([]*SignedTxn, error)
func PackFor(numLimit uint64, filter func(*SignedTxn) error) ([]*SignedTxn, error)
</code></pre>
<p><code>Pack(numLimit)</code>表示从交易池最多打包<code>numLimit</code>个交易，被打包的交易会被标记， 但是不会立马从交易池中删除。<br />
<code>PackFor(numLimit, filter)</code> 比 <code>Pack</code>多一个过滤功能，所有被打包的交易必须通过<code>filter</code>的过滤，如果<code>filter</code>返回一个错误，则该交易不会被打包。</p>
<h2 id="-9"><a class="header" href="#-9"></a></h2>
<pre><code class="language-go">func GetTxn(hash Hash) (*SignedTxn, error)
func Flush() error
</code></pre>
<p><code>GetTxn(hash)</code> 根据交易哈希值 获取交易数据。<br />
<code>Flush()</code> 删除被打包的交易。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鼎"><a class="header" href="#鼎">鼎</a></h1>
<h2 id="tripod"><a class="header" href="#tripod">tripod</a></h2>
<h4 id="概述"><a class="header" href="#概述">概述</a></h4>
<p><code>tripod</code>是整个yu框架的核心所在，开发者通过实现它的interface来定义自己的业务逻辑。 它由三部分构成：</p>
<ol>
<li>自定义区块验证规则和交易检查逻辑</li>
<li>控制区块的生命周期从而实现深度定制化开发。生命周期有四个阶段：<code>initChain</code>, <code>startBlock</code>, <code>endBlock</code>, <code>finalizeBlock</code>。 其中只有<code>initChain</code>
是只有在创世区块的时候才被调用的，后面三个是每次区块都会被调用。 （个性化共识算法便可以用区块生命周期来实现）</li>
<li>自定义 <code>交易</code>(Execution) 和 <code>查询</code>(Query) </li>
</ol>
<h4 id="接口-2"><a class="header" href="#接口-2">接口</a></h4>
<p>代码定义在<a href="https://github.com/Lawliet-Chan/yu/blob/master/tripod/tripod.go">这里</a></p>
<pre><code class="language-go">func GetTripodMeta() *TripodMeta
func Name() string
</code></pre>
<p><code>GetTripodMeta()</code>返回一个<code>tripod</code>的元数据，该元数据定义在<a href="https://github.com/Lawliet-Chan/yu/blob/master/tripod/tripod_meta.go#L11">这里。</a>
该元数据中囊括了 <code>Execution</code> 和 <code>Query</code>列表。<br />
<code>Name()</code>返回<code>tripod</code>的名称。</p>
<h2 id="-10"><a class="header" href="#-10"></a></h2>
<pre><code class="language-go">func CheckTxn(*SignedTxn) error
func VerifyBlock(block IBlock, env *ChainEnv) bool
</code></pre>
<p><code>checkTxn()</code>是开发者自定义的交易检查逻辑，前面的章节提到过当外部有交易进来插入<code>txpool</code>的时候，会执行<code>BaseChack</code> 和 <code>TripodsCheck</code> 这两步检查，
而<code>TripodsCheck</code>便是在这里定义，每个<code>tripod</code>都可以定义自己的交易检查逻辑。<br />
<code>VerifyBlock()</code>是开发者自定义的区块校验逻辑，区块链每收到一个外部广播来的区块都需要校验过后才能进行后续处理，不同的链有对区块不同的校验方式，所以 
开发者可以自己定制校验逻辑。 每个<code>tripod</code>都可以定义自己的交易检查逻辑。</p>
<h2 id="-11"><a class="header" href="#-11"></a></h2>
<pre><code class="language-go">func InitChain(env *ChainEnv, land *Land) error
func StartBlock(block IBlock, env *ChainEnv, land *Land) (needBroadcast bool, err error)
func EndBlock(block IBlock, env *ChainEnv, land *Land) error
func FinalizeBlock(block IBlock, env *ChainEnv, land *Land) error
</code></pre>
<p><code>InitChain()</code>只会在区块链启动的时候被调用一次，专门用来定义处理<code>创世区块</code>。<br />
<code>StartBlock()</code>定义区块生成时的阶段的逻辑，并且需要返回一个类型为<code>bool</code>的<code>needBroadcast</code>返回值   告诉框架是否需要广播区块。一般如果是本地挖到的区块，是需要广播出去的，如果是从其他节点
获取到的区块，则没必要广播。<br />
<code>EndBlock()</code>定义区块结束时候的逻辑，一般会在这里执行交易并且将区块存入区块链中。<br />
<code>FinalizeBlock()</code>定义区块的<code>敲定阶段</code>（即最终共识）的逻辑。如果区块链是<code>finalize类型的链</code>，则需要定制这部分逻辑，否则便不必要。</p>
<h2 id="land"><a class="header" href="#land">land</a></h2>
<p><code>land</code>用来装载所有的<code>tripod</code> 供框架调用。</p>
<h4 id="land内部流程图"><a class="header" href="#land内部流程图"><code>land</code>内部流程图</a></h4>
<p><img src="land%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态"><a class="header" href="#状态">状态</a></h1>
<p><code>state</code>是链上状态存储，比如A给B发起一次链上转账之后，A和B的账户余额信息都会存储下来。 以下我们把每个交易中的 所有对状态存储的操作 称作一个<code>事务</code>。<br />
<code>state</code>中事务具备原子性， 比如一个交易中一共有3个修改状态的操作，那么这3个操作要不然都能修改成功，要么都不成功。
举例如下:</p>
<pre><code class="language-go">func (a *A) DoTest(ctx *context.Context, env *ChainEnv) error {
    env.KVDB.Set(a, []byte(&quot;yu&quot;), []byte(&quot;yu&quot;)) // 1. 修改状态

    err := DoOther()
    if err != nil {
        return err
    }

    env.KVDB.Set(a, []byte(&quot;qi&quot;), []byte(&quot;qi&quot;)) // 2. 修改状态
}
</code></pre>
<p>上述代码中，一共有两处 <code>修改状态</code> 的操作， 如果代码在第一处执行成功， 但是在<code>DoOther()</code>这里执行出错返回，那么第二处的<code>修改状态</code>就无法完成了，此时
框架会一并把第一处的状态修改 取消掉 来保证原子性。</p>
<p>状态存储的组件名为<code>StateStore</code>，目前内部暂时只支持kvdb的存储形式。 状态存储 以区块为单位，按顺序依次执行每个区块内的事务都存入到数据库中。 </p>
<p>代码在<a href="https://github.com/Lawliet-Chan/yu/blob/master/state/store.go">这里</a></p>
<pre><code class="language-go">func StartBlock(blockHash)
</code></pre>
<p><code>StartBlock()</code>在区块链运行的 <code>start block</code>阶段调用，用来告知<code>state</code>当前的区块哈希。</p>
<pre><code class="language-go">func SetCanRead(blockHash)
</code></pre>
<p><code>SetCanRead()</code>设置当前可以被读的区块中的状态。 一个区块交易执行完毕被存入链后，可能并不是立马就允许被读到的，尤其是<code>finalize类型的链</code>，需要
等到该区块被<code>finalize</code>之后该区块内执行的结果状态才可以被外界读到。 当然<code>非finalize类型的链</code>可以在区块被存进链后立马就被读到。</p>
<pre><code class="language-go">func Commit() (Hash, error)
</code></pre>
<p><code>Commit()</code>提交该区块内所有事务，并返回该区块下的状态树的 <code>stateroot</code>。</p>
<pre><code class="language-go">func Discard()
</code></pre>
<p><code>Discard()</code>取消当前事务。</p>
<pre><code class="language-go">func DiscardAll()
</code></pre>
<p><code>DiscardAll()</code>取消当前区块内所有的事务。</p>
<pre><code class="language-go">func NextTxn()
</code></pre>
<p><code>NextTxn()</code>表示当前事务执行完，开始执行下一个事务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发者手册"><a class="header" href="#开发者手册">开发者手册</a></h1>
<p>本章节将详细介绍 如何使用 <code>yu</code>开发区块链的细节。即如何构建自己的 <code>tripod</code>  </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h1>
<p>yu的配置文件的格式是<code>.toml</code>。<br />
配置内容分以下几个部分， 代码在<a href="https://github.com/Lawliet-Chan/yu/blob/master/config/config.go#L9">这里</a></p>
<ul>
<li>节点自身配置</li>
<li>各组件配置</li>
<li>P2P网络相关配置</li>
<li>nodekeeper配置 （暂时无用）</li>
</ul>
<p><code>yu</code> 默认的配置文件路径为 <code>yu_conf/master.toml</code>。 当然，如果不想手动填写配置文件，也可以像<a href="2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html">快速开始</a>里一样启用命令行 
<code>-dc=true</code> 来利用默认配置。 默认配置的源码地址在<a href="https://github.com/Lawliet-Chan/yu/blob/master/startup/startup.go#L70">这里</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="节点配置"><a class="header" href="#节点配置">节点配置</a></h1>
<h4 id="源码样式"><a class="header" href="#源码样式">源码样式：</a></h4>
<pre><code class="language-go">    // 0: local-node
	// 1: master-worker
	RunMode RunMode `toml:&quot;run_mode&quot;`
	// serve http port
	HttpPort string `toml:&quot;http_port&quot;`
	// serve websocket port
	WsPort string `toml:&quot;ws_port&quot;
    
        LeiLimit uint64 `toml:&quot;lei_limit&quot;`
</code></pre>
<ul>
<li>Runmode: 为节点运行方式， 0为单节点形式运行，1为<code>master-worker</code>形式运行（<code>master-worker</code>形式暂不支持） </li>
<li>HttpPort: http监听地址，服务于外部调用的端口配置。</li>
<li>WsPort: websocket监听地址，服务于外部调用的端口配置。</li>
<li>LeiLimit： 每个区块里可以被消耗的 <code>lei</code> 的上限</li>
</ul>
<h4 id="配置示例"><a class="header" href="#配置示例">配置示例：</a></h4>
<pre><code class="language-toml">run_mode = 0

http_port = &quot;7998&quot;

ws_port = &quot;8998&quot;

lei_limit = 50000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="各组件配置"><a class="header" href="#各组件配置">各组件配置</a></h1>
<h4 id="blockchain配置源码"><a class="header" href="#blockchain配置源码"><code>blockchain</code>配置源码:</a></h4>
<pre><code class="language-go">type BlockchainConf struct {
	ChainDB         SqlDbConf `toml:&quot;chain_db&quot;`
	BlocksFromP2pDB SqlDbConf `toml:&quot;blocks_from_p2p_db&quot;`
}
</code></pre>
<ul>
<li>ChainDB: 用来存储区块链的sql数据库</li>
<li>BlocksFromP2pDB: 用来缓存来自P2P网络的其他合法区块的sql数据库</li>
</ul>
<h4 id="blockbase配置源码"><a class="header" href="#blockbase配置源码"><code>blockbase</code>配置源码:</a></h4>
<pre><code class="language-go">type BlockBaseConf struct {
	BaseDB SqlDbConf `toml:&quot;base_db&quot;`
}
</code></pre>
<ul>
<li>BaseDB: 用来存储 <code>blockbase</code> 的sql数据库。</li>
</ul>
<h4 id="txpool配置源码"><a class="header" href="#txpool配置源码"><code>txpool</code>配置源码:</a></h4>
<pre><code class="language-go">type TxpoolConf struct {
	PoolSize   uint64    `toml:&quot;pool_size&quot;`
	TxnMaxSize int       `toml:&quot;txn_max_size&quot;`
	Timeout    int       `toml:&quot;timeout&quot;`
}
</code></pre>
<ul>
<li>PoolSize: 交易池池大小，如果超过该大小，则后续交易将不会被放进交易池</li>
<li>TxnMaxSize：最大交易的数据量大小，如果一条交易超过该配置，则不会被放进交易池</li>
<li>Timeout: 交易池超时时间，超过该时间则交易不会被放进交易池（目前该功能暂时未实现）</li>
</ul>
<h4 id="state配置源码"><a class="header" href="#state配置源码"><code>state</code>配置源码:</a></h4>
<pre><code class="language-go">type StateConf struct {
	KV StateKvConf `toml:&quot;kv&quot;`
}
</code></pre>
<p>目前 <code>state</code>只支持<code>kvdb</code>这一种存储方式，未来还会开放更多存储形式 </p>
<h3 id="配置示例-1"><a class="header" href="#配置示例-1">配置示例:</a></h3>
<pre><code class="language-toml">[block_chain.chain_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;chain.db&quot;

[block_chain.blocks_from_p2p_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;blocks_from_p2p.db&quot;

[block_base.base_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;blockbase.db&quot;

[txpool]
pool_size = 2048
txn_max_size = 1024000

[state.kv.index_db]
kv_type = &quot;bolt&quot;
path = &quot;./state_index.db&quot;

[state.kv.node_base]
kv_type = &quot;bolt&quot;
path = &quot;./state_base.db&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="p2p网络配置"><a class="header" href="#p2p网络配置">p2p网络配置</a></h1>
<h4 id="源码样式-1"><a class="header" href="#源码样式-1">源码样式:</a></h4>
<pre><code class="language-go">    // For listening from blockchain network.
	P2pListenAddrs []string `toml:&quot;p2p_listen_addrs&quot;`
	// To connect other hosts as a p2p network.
	Bootnodes []string `toml:&quot;bootnodes&quot;`

	ProtocolID string `toml:&quot;protocol_id&quot;`
	// 0: RSA
	// 1: Ed25519
	// 2: Secp256k1
	// 3: ECDSA
	NodeKeyType int `toml:&quot;node_key_type&quot;`

	NodeKeyRandSeed int64 `toml:&quot;node_key_rand_seed&quot;`

	NodeKey string `toml:&quot;node_key&quot;`

	// Only RSA has this param.
	NodeKeyBits int `toml:&quot;node_key_bits&quot;`
	// When use param 'NodeKey', 'NodeKeyFile' will not work.
	NodeKeyFile string `toml:&quot;node_key_file&quot;`
</code></pre>
<ul>
<li>P2pListenAddrs: 表示区块链节点监听的P2P协议的地址</li>
<li>Bootnodes: 链接P2P网络中的其他区块链节点，用来同步历史区块</li>
<li>ProtocolID: P2P网络里自定义的协议名称</li>
<li>NodeKeyType: P2P节点的key的加密类型，用来生成p2p地址的 key。目前支持四种加密算法：
<ul>
<li><code>0</code>表示<code>RSA</code></li>
<li><code>1</code>表示<code>Ed25519</code></li>
<li><code>2</code>表示<code>Secp256k1</code></li>
<li><code>3</code>表示<code>ECDSA</code></li>
</ul>
</li>
<li>NodeKeyRandSeed: 生成p2p节点的key的种子，用来生成P2P地址的key。当该项不为空时，则无需配置<code>NodeKey</code>了。</li>
<li>NodeKey：P2P地址的key，用来生成p2p地址。当<code>NodeKeyRandSeed</code>不为空时，该项可不填。</li>
<li>NodeKeyBits: key的比特位，此配置只有<code>RSA</code>这个加密算法才需要。 其他类型的加密算法并不需要配置该参数。</li>
<li>NodeKeyFile: 读取p2p地址的key的文件， 只有 <code>NodeKey</code>为空的时候，系统才会读取该配置项。</li>
</ul>
<h4 id="配置示例-2"><a class="header" href="#配置示例-2">配置示例：</a></h4>
<pre><code class="language-toml">
p2p_listen_addrs = [&quot;/ip4/127.0.0.1/tcp/8887&quot;]

protocol_id = &quot;yu&quot;

node_key_type = 1
node_key_rand_seed = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodekeeper"><a class="header" href="#nodekeeper">NodeKeeper</a></h1>
<p>该配置在当前版本暂没用处， 不过仍需配置。 只需按本节提供的默认示例配置即可。</p>
<h4 id="源码样式-2"><a class="header" href="#源码样式-2">源码样式：</a></h4>
<pre><code class="language-go">    NkDB KVconf `toml:&quot;nk_db&quot;`
	// when beyond 'Timeout', it means this nodekeeper is down.
	// Unit is Second.
	Timeout int `toml:&quot;timeout&quot;`
</code></pre>
<ul>
<li>NkDB: nodeKeeper的KV数据库配置</li>
<li>Timeout: </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-与-chainenv"><a class="header" href="#context-与-chainenv">Context 与 ChainEnv</a></h1>
<p>在<a href="2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html">快速开始</a>中，我们已经看到了如何自定义一个 <code>Execution</code>，此处有两个参数， 一个是<code>context</code>，一个是<code>ChainEnv</code>,他们分别表示两个不同
的用途。</p>
<p><a href="https://github.com/Lawliet-Chan/yu/tree/master/context">Context</a> 表示与链外交互的上下文信息。 它包括 <code>调用者地址</code>、<code>传入的参数</code>、
<code>event</code>、<code>error</code>。</p>
<ul>
<li>客户端调用者（即发起交易的人）传入的参数会以json的形式序列化，并按 <code>string -&gt; interface{}</code> 这样map的方式存在 <code>context</code> 中。<br />
我们通过<code>context</code>获取 客户端调用者的<code>密码学地址</code> 和 调用者传入的<code>参数</code>。  从<code>context</code>
获取参数的时候可以以<a href="https://github.com/Lawliet-Chan/yu/blob/master/context/params.go#L18-L257">任意go基础类型</a> 去获取参数。
如果参数类型为自定义的，则需要先通过<code>context.Get(paramName)</code>获取到 <code>interface</code>再自行转化。可以直接获取参数的类型有:</li>
</ul>
<pre><code class="language-go">   common.Hash([32]byte)
   common.Address([20]byte)
   string
   []byte
   bool 
   int, int8, int16, int32, int64
   uint, uint8, uint16, uint32, uint64
   float32, float64
</code></pre>
<ul>
<li>同时如果需要向链外返回 <code>event</code>的时候， 也需要通过<code>context</code>来完成(<code>ctx.EmitEvent(interface{})</code>)。</li>
</ul>
<p><a href="https://github.com/Lawliet-Chan/yu/blob/master/chain_env/env.go">ChainEnv</a> 包含了所有链相关的一切环境组件，其中有 <code>blockchain</code>、
<code>blockbase</code>、 <code>txpool</code>、 <code>state</code>等。 可供开发者直接操作到框架底层的组件。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-和-query"><a class="header" href="#execution-和-query">Execution 和 Query</a></h1>
<p>正常情况下，开发者们对 <code>Execution</code> 和 <code>Query</code> 会用到的更多一些， 因为这基本是完全业务层面的对外读写接口。所以本节我们看一下在<code>yu</code>当中，如何
使用它们。</p>
<p>定义如下:</p>
<pre><code class="language-go">type (
	Execution func(*context.Context, *chain_env.ChainEnv) error
	
	Query func(*context.Context, *chain_env.ChainEnv, common.Hash) (respObj interface{}, err error)
)
</code></pre>
<ul>
<li>
<p><code>Execution</code>在以太坊等其他区块链当中被称作<code>交易</code>， 说到底其实就是<code>一次对于链上状态的写操作</code>， 所以这样的操作会同步到全网。<br />
当需要修改链上状态的时候， 需要调用 <code>chainEnv.KVDB</code>来进行状态修改。注意， <code>chainEnv.kvdb</code>内的<code>set</code>、<code>get</code>、 <code>delete</code>函数的第一个参数必须为当前 <code>tripod</code>
指针， 比如 <a href="2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html">快速开始</a>里的 <code>env.KVDB.Set(e, ..., ...)</code><br />
当需要发送 <code>event</code>到链外的时候，调用 <code>ctx.EmitEvent()</code>。</p>
</li>
<li>
<p><code>Query</code>就是链上查询，它不对链上状态有任何修改，所以该操作并不会被同步到全网。 <code>Query</code>的参数比 <code>Execution</code>多一个 <code>common.Hash</code>， 这个参数是个 
区块哈希值, 是用来指定查询某个区块时刻上的历史状态的，如果不是查询历史状态，我们可以忽略这个参数。<br />
状态查询调用 <code>env.KVDB.Get()</code> 或者 <code>env.KVDB.GetByBlockHash()</code>。前者是查询现在主链上已经达成最终共识的状态；后者是查询具体的某个区块上的
历史状态的。<br />
<code>respObj</code>用来把查询到的状态值返回到链外。</p>
</li>
<li>
<p><code>注入Tripod中</code>：当构建好自己所有的<code>Execution</code> 和 <code>Query</code>的时候， 需要我们调用 <code>tripod.SetExecs()</code>把所有<code>Execution</code>注入到<code>tripod</code>中，
并且调用<code>tripod.SetQueries()</code>把所有<code>Query</code>注入到<code>tripod</code>中。</p>
</li>
<li>
<p><code>装填到land里</code>：框架提供了一个 <a href="https://github.com/Lawliet-Chan/yu/blob/master/startup/startup.go#L31">启动入口</a> 只要在启动的时候
把自己构建的所有 <code>tripod</code> 通过调用 <code>StartUp(...Tripod)</code>来完成装填，由此告知框架我们定制了哪些<code>tripod</code>。</p>
</li>
</ul>
<h4 id="关于-defaulttripod"><a class="header" href="#关于-defaulttripod">关于 defaultTripod</a></h4>
<p>当你不需要自定义控制 <code>区块周期</code>  而只想开发 <code>Execution</code> 和 <code>Query</code> 的时候， <a href="https://github.com/Lawliet-Chan/yu/blob/master/tripod/default_tripod.go">defaultTripod</a>
便可以帮你少写很多代码， 你需要将它放在你自定义实现的 <code>tripod</code> 结构体的第一个成员变量即可（必须要省略变量名来达到继承 <code>defaultTripod</code>的效果）。如下：</p>
<pre><code class="language-go">type Example struct {
	*tripod.DefaultTripod
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块周期"><a class="header" href="#区块周期">区块周期</a></h1>
<p><a href="4.4tripod.html">前面</a> 有详细介绍过 <code>tripod</code>内关于区块周期的概念。 通过定制区块周期，我们可以实现很多深度的功能， 比如共识算法。 下面我们以
基于sha256算法的 pow共识 为例，代码原址<a href="https://github.com/Lawliet-Chan/yu/blob/master/apps/pow/pow.go">在这里</a> 。</p>
<ul>
<li>初始化区块链，构造创世区块</li>
</ul>
<pre><code class="language-go">    func (*Pow) InitChain(env *ChainEnv, _ *Land) error {
    	chain := env.Chain
    	gensisBlock := &amp;Block{
    		Header: &amp;Header{},
    	}
    	return chain.SetGenesis(gensisBlock)
    }
</code></pre>
<ul>
<li>区块开始时，构造区块</li>
</ul>
<pre><code class="language-go">func (p *Pow) StartBlock(block IBlock, env *ChainEnv, _ *Land) (needBroadcast bool, err error) {
    ......

    // 获取主链中的上一个区块，来确认本次区块的高度等等数据。
    prevBlock, err := chain.GetEndBlock()

    ......

    // 从P2P网络中获取该区块高度上的合法区块（来自其他节点），如果有则表示该高度的区块已经被别的节点挖到，直接返回。
    pbsht, err := chain.TakeP2pBlocks(height)
    if err != nil {
   	logrus.Errorf(&quot;get p2p-blocks error: %s&quot;, err.Error())
    }
    if len(pbsht) &gt; 0 {
   	block.CopyFrom(pbsht[0])
   	logrus.Infof(&quot;USE P2P block(%s)&quot;, block.GetHash().String())
   	env.StartBlock(block.GetHash())
   	return
    }
    
    // 如果从P2P网络中发现该区块高度上没有合法的区块， 则需要我们开始挖矿。
    // 所以这里把 needBroadcast置为true，表示我们会挖到这个区块并将它广播到P2P网络中去，
    // 具体的广播实现由框架帮我们去代劳了。
    needBroadcast = true

    ......

    // 从交易池打包交易（最多打包pkgTxnsLimit个)
    txns, err := pool.Pack(p.pkgTxnsLimit)
    if err != nil {
    	return
    }

    ......

    // 为该区块计算出了一个合法的哈希值（即挖到矿了）
    nonce, hash, err := spow.Run(block, p.target, p.targetBits)
    if err != nil {
        return
    }

    block.(*Block).SetNonce(uint64(nonce))
    block.SetHash(hash)

    ......

    return 
}
</code></pre>
<ul>
<li>区块结束时</li>
</ul>
<pre><code class="language-go">func (*Pow) EndBlock(block IBlock, env *ChainEnv, land *Land) error {
        ......

        // 执行区块中的所有交易
	err := node.ExecuteTxns(block, env, land)
	if err != nil {
		return err
	}

        // 把该区块持久化存入链中
	err = chain.AppendBlock(block)
	if err != nil {
		return err
	}

        ......
        // 清除交易池，为下一个区块的交易准备  
        return pool.Flush()   
}

</code></pre>
<ul>
<li>最终共识，敲定区块： 
由于 pow共识 一般是不需要最终共识的这个敲定阶段的， 因为他们有最长子链或者最重子链等证明算力的方式。 所以这里我们 <code>FinalizeBlock()</code>不用实现。 </li>
</ul>
<pre><code class="language-go">func (*Pow) FinalizeBlock(_ IBlock, _ *ChainEnv, _ *Land) error {
	return nil
}
</code></pre>
<p>到此为止，一个基于 sha256的 pow共识机制 便完成了。</p>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
